import requests
import sys, os
import json
import time
import re
from bs4 import BeautifulSoup
from urllib.parse import urlparse, urljoin

# [X] 다운로드 파일이 저장된 디렉터리 이외에 접근 가능한 경우 주요 서비스 및 서버 정보 유출 가능성이 존재할 경우
# [∆] 다운로드 파일이 저장된 디렉터리 이외에 접근이 가능한 경우
# [O] 다운로드 파일이 저장된 디렉터리 접근이 불가능한 경우

def exploitsFile(x_file):
    with open(x_file,'r') as file:
        explits = file.read().splitlines()
    return explits

def p_inspec_url(url, check_files):
    inspection_url_1 = []
    form_value = []
    for file in check_files:
        # 페이지 내용 가져오기
        response = requests.get(file)
        soup = BeautifulSoup(response.text, 'html.parser')

        # form 태그 찾기 + input, textarea, select, button
        form = soup.find('form')
        if form is None:
            continue
        # print(f"Checking {file}")
        
        # 해당 데이터를 분석 후 저장할 딕셔너리
        form_data = {
            "method" : form.get('method', '').upper(),
            "action" : form.get('action',''),
            "input_fields": [],
            "textarea_fields": [],
            "select_fields": [],
            "button_fields": []            
        }
        
        # input 태그 속성 데이터 식별
        inputs = form.find_all('input')
        for i in inputs:
            input_info = {
                "name": i.get('name'),
                "type": i.get('type')
            }
            form_data["input_fields"].append(input_info)

        # textarea 태그 속성 데이터 식별
        textareas = form.find_all('textarea')
        for i in textareas:
            textarea_info = {
                "name": i.get('name')
            }
            form_data["textarea_fields"].append(textarea_info)
        
        # select 태그 속성 데이터 식별
        selects = form.find_all('select')
        for i in selects:
            select_info = {
                "name": i.get('name')
            }
            form_data["select_fields"].append(select_info)    

        # button 태그 속성 데이터 식별
        buttons = form.find_all('button')
        for i in buttons:
            button_info = {
                "name": i.get('name')
            }
            form_data["button_fields"].append(button_info)        

        action_url = urljoin(url, form_data["action"])

        form_value.append(form_data)
        inspection_url_1.append(action_url)

    return form_value, inspection_url_1

def g_inspec_url(parameter_values):
    result_urls = [url.split('?')[0] for url in parameter_values if '?' in url]
    method = []
    for file in result_urls:
        response = requests.get(file)
        soup = BeautifulSoup(response.text, 'html.parser')

        form = soup.find('form')
        if form is not None:
            method.append("POST")
        else:
            method.append("GET")
    
    return method, result_urls

def pathManipulationFD_POST(action, method, param):
    print(f"\nAttack URL(pathManipulationFD_POST): {action}")
    query_params = urlparse(param).query.split('&')
    query_key = query_params[0].split('=')[0]
    url = action

    x_file = "./Inter_YourCode-X/VulnerabilityList/FD/path_manipulation_post.txt"
    exploits = exploitsFile(x_file)

    # URL에서 파일 이름 추출
    file_name = urlparse(url).path.split('/')[-1]
    file_list = [file_name, f"../{file_name}", f"../../{file_name}", f"../../../{file_name}", f"../../../../{file_name}"]
    file_list += exploits

    for file_value in file_list:
        params = {query_key: file_value}
        response = requests.post(url, data=params)

        # 응답이 성공적일 경우에만 파일에 쓰기
        if 200 <= response.status_code < 300:
            response_text = response.content.decode()
            error_messages = ["데이터 베이스 오류", "Database Error", "로그인"]
            if not any(error_message in response_text for error_message in error_messages):
                with open("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt", "wb") as f:
                    f.write(response.content)        
                
                # 파일이 작성되었는지 확인
                if os.path.exists("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt"):
                    print(f"parameter value: {query_key}")
                    print(f"Attack Detected: {file_value}", file=sys.stdout)
                    print(f"Risk: 위험", file=sys.stdout)
                    print(f"Target url: {action}", file=sys.stdout)
                    print(f"Detail payload: Path Manipulation File Download", file=sys.stdout)

                    # 추가 분석
                    with open("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt", "r", encoding="utf-8") as file:
                        file_content = file.read()       
                    # getRealPath() 안의 변수를 찾는 정규 표현식 패턴
                    pattern = r"getRealPath\((.*?)\)"
                    matches = re.findall(pattern, file_content)

                    if matches:
                        variable_in_getRealPath = matches[0] if matches else None
                        # 변수 이름을 찾는 정규 표현식 패턴
                        pattern = fr'String {variable_in_getRealPath}\s*=\s*"(.*?)"'
                        matches = re.findall(pattern, file_content)
                        # 첫 번째 매치를 사용 (변수 이름이 한 번만 사용되었다고 가정)
                        variable_value  = matches[0] if matches else None
                        print(f"Estimated file upload path: {variable_value}", file=sys.stdout)

                    # 파일 삭제
                    os.remove('./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt')
                    print(f"File removed.")     


def pathManipulationFD_GET(action, param):
    print(f"\nAttack URL(pathManipulationFD_GET): {action}")
    query_params = urlparse(param).query.split('&')
    query_key = query_params[0].split('=')[0]
    url = action

    x_file = "./Inter_YourCode-X/VulnerabilityList/FD/path_manipulation_get.txt"
    exploits = exploitsFile(x_file)

    # URL에서 파일 이름 추출
    file_name = urlparse(url).path.split('/')[-1]
    file_list = [file_name, f"../{file_name}", f"../../{file_name}", f"../../../{file_name}", f"../../../../{file_name}"]
    file_list += exploits

    for file_value in file_list:
        params = {query_key: file_value}
        response = requests.get(url, params=params)

        # 응답이 성공적일 경우에만 파일에 쓰기
        if 200 <= response.status_code < 300:
            response_text = response.content.decode()
            error_messages = ["데이터 베이스 오류", "Database Error", "로그인"]
            if not any(error_message in response_text for error_message in error_messages):
                with open("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt", "wb") as f:
                    f.write(response.content)        
                
                # 파일이 작성되었는지 확인
                if os.path.exists("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt"):
                    print(f"parameter value: {query_key}")
                    print(f"Attack Detected: {file_value}", file=sys.stdout)
                    print(f"Risk: 위험", file=sys.stdout)
                    print(f"Target url: {action}", file=sys.stdout)
                    print(f"Detail payload: Path Manipulation File Download", file=sys.stdout)

                    # 추가 분석
                    with open("./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt", "r", encoding="utf-8") as file:
                        file_content = file.read()       
                    # getRealPath() 안의 변수를 찾는 정규 표현식 패턴
                    pattern = r"getRealPath\((.*?)\)"
                    matches = re.findall(pattern, file_content)

                    if matches:
                        variable_in_getRealPath = matches[0] if matches else None
                        # 변수 이름을 찾는 정규 표현식 패턴
                        pattern = fr'String {variable_in_getRealPath}\s*=\s*"(.*?)"'
                        matches = re.findall(pattern, file_content)
                        # 첫 번째 매치를 사용 (변수 이름이 한 번만 사용되었다고 가정)
                        variable_value  = matches[0] if matches else None
                        print(f"Estimated file upload path: {variable_value}", file=sys.stdout)

                    # 파일 삭제
                    os.remove('./Inter_YourCode-X/Windows_YourCode-X/downloaded_file.txt')
                    print(f"File removed.")


# main에서 매개변수로 전달된 url, check_url, identi_paths 받아와서 점검 항목 수행
if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Error code: url[1], check_url[2], identi_json[3] 인자 전달받지 못함")
        sys.exit(1)
    url = sys.argv[1]
    urls_json = json.loads(sys.argv[2])
    identi_json = json.loads(sys.argv[3])
    
    # identi_paths(identi_json)의 파라미터('?', '=') 값과 올바른 경로 유추
    # http://.../\"javascript:copyFile('"+folderReplace(file)+"')\" 이런 경로는 제외
    check_identis = [identi for identi in identi_json if '?' in identi and '=' in identi]
    
    # 해당 파라미터들만 추출
    # http://.../01_FileDown.jsp?file_name=, ...
    parameter_values_s = set(identi.split('=')[0] + '=' for identi in check_identis)
    for identi in check_identis:
        if '&' in identi:
            parameter_values_s.add(identi)
    parameter_values = list(parameter_values_s)  
    
    # 정적인 확장자 제외한 check_files_1
    static_extensions = {'.jpg', '.jpeg', '.png', '.css', '.js'}
    check_files_1 = [file for file in urls_json if os.path.splitext(file)[1] not in static_extensions]    

    # POST 방식 추출을 위한 호출
    form_data_1, action_url_1 = p_inspec_url(url, check_files_1)    
    
    # GET 방식 추출을 위한 호출
    methods, action_url_2 = g_inspec_url(parameter_values)
    
    # 점검 url
    inspection_url = action_url_1 + action_url_2
    for target in inspection_url:
        print(f"Inspection_url: {target}", file=sys.stdout)

    # Path Manipulation(POST)
    for action, form_data, param in zip(action_url_1, form_data_1, parameter_values):
        method = form_data["method"]
        pathManipulationFD_POST(action, method, param)
    
    # Path Manipulation(GET)
    for action, param in zip(action_url_2, parameter_values):
        pathManipulationFD_GET(action, param)